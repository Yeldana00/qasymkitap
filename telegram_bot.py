# telegram_bot.py
import pandas as pd
import psycopg2 # –ò—Å–ø–æ–ª—å–∑—É–µ–º psycopg2 –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application, CommandHandler, MessageHandler, 
    filters, ContextTypes, CallbackQueryHandler
)
import logging
import os
from dotenv import load_dotenv

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- –ó–∞–≥—Ä—É–∑–∫–∞ —Å–µ–∫—Ä–µ—Ç–æ–≤ ---
# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env (–¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞)
# –ù–∞ —Ö–æ—Å—Ç–∏–Ω–≥–µ (Railway) –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç –∑–∞–¥–∞–Ω—ã –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
load_dotenv() 

TOKEN = os.getenv("TOKEN")
DATABASE_URL = os.getenv("DATABASE_URL")

# --- (1) –ó–ê–ì–†–£–ó–ö–ê –î–ê–ù–ù–´–• –ò–ó POSTGRES –ò –ü–û–î–ì–û–¢–û–í–ö–ê –ú–û–î–ï–õ–ò ---

def load_data_from_db():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ PostgreSQL –≤ DataFrame –∏ –≥–æ—Ç–æ–≤–∏—Ç –º–æ–¥–µ–ª—å."""
    
    if not DATABASE_URL:
        logger.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: DATABASE_URL –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        exit()
        
    try:
        logger.info("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ PostgreSQL...")
        # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –±–∞–∑–µ
        with psycopg2.connect(DATABASE_URL) as conn:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã 'books' –≤ pandas DataFrame
            sql = "SELECT * FROM books"
            df = pd.read_sql_query(sql, conn)
        
        logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(df)} –∫–Ω–∏–≥ –∏–∑ –ë–î.")
        
        # --- –î–∞–ª—å–Ω–µ–π—à–∞—è –ª–æ–≥–∏–∫–∞ –∏–¥–µ–Ω—Ç–∏—á–Ω–∞ SQLite ---
        
        df['–ê—Ç—ã'] = df['–ê—Ç—ã'].fillna('')
        df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'] = df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'].fillna('–ë–µ–ª–≥—ñ—Å—ñ–∑')
        df['–¢–æ–ª—ã“ì—ã—Ä–∞“õ'] = df['–¢–æ–ª—ã“ì—ã—Ä–∞“õ'].fillna('')
        df['–ê–≤—Ç–æ—Ä'] = df['–ê–≤—Ç–æ—Ä'].fillna('')

        category_mapping = {cat: i for i, cat in enumerate(df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'].unique())}
        df['Category_Numeric'] = df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'].map(category_mapping).fillna(-1)

        kazakh_stop_words = [
            '–∂”ô–Ω–µ', '–Ω–µ–º–µ—Å–µ', '–±—ñ—Ä–∞“õ', '“Ø—à—ñ–Ω', '–¥–µ–π—ñ–Ω', '–±–∞—Å—Ç–∞–ø', '–∂–æ“õ', '–±–∞—Ä', 
            '–±–∞—Ä–ª—ã“õ', '”ô—Ä', '–∫”©–ø', '–∞–∑', '–±–æ–ª–∞–¥—ã'
        ]
        
        tfidf = TfidfVectorizer(stop_words=kazakh_stop_words)
        
        df['combined'] = (
            df['–ê—Ç—ã'].str.lower() + ' ' + 
            df['–¢–æ–ª—ã“ì—ã—Ä–∞“õ'].str.lower() + ' ' + 
            df['–ê–≤—Ç–æ—Ä'].str.lower() + ' ' + 
            df['Category_Numeric'].astype(str)
        )
        
        tfidf_matrix = tfidf.fit_transform(df['combined'])
        cosine_sim_matrix = cosine_similarity(tfidf_matrix, tfidf_matrix)
        
        logger.info("–ú–æ–¥–µ–ª—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π (TF-IDF) –≥–æ—Ç–æ–≤–∞!")
        
        return df, cosine_sim_matrix

    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î: {e}")
        exit()

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ: –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ 1 —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ ---
books_df, cosine_sim = load_data_from_db()

# --- (2) –õ–û–ì–ò–ö–ê –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ô (–æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---

def get_recommendations(book_title: str) -> pd.DataFrame:
    book_title = book_title.lower()
    idx_list = books_df.index[
        (books_df['–ê—Ç—ã'].str.lower().str.contains(book_title, na=False)) | 
        (books_df['–¢–æ–ª—ã“ì—ã—Ä–∞“õ'].str.lower().str.contains(book_title, na=False))
    ].tolist()
    
    if not idx_list: return pd.DataFrame()
    idx = idx_list[0]
    top_indices = [i[0] for i in sorted(enumerate(cosine_sim[idx]), key=lambda x: x[1], reverse=True)[1:6]]
    return books_df.iloc[top_indices]

def format_book_message(book: pd.Series) -> str:
    if pd.notna(book['–ë–∞“ì–∞—Å—ã']):
        price = f"{book['–ë–∞“ì–∞—Å—ã']:,.0f} —Ç–≥".replace(',', ' ')
    else:
        price = "–ë–∞“ì–∞—Å—ã –±–µ–ª–≥—ñ—Å—ñ–∑"
    
    message = (
        f"üìö <b>{book['–ê—Ç—ã']}</b>\n"
        f"üë§ –ê–≤—Ç–æ—Ä—ã: {book['–ê–≤—Ç–æ—Ä']}\n"
        f"üóÇ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {book['–ö–∞—Ç–µ–≥–æ—Ä–∏—è']}\n"
        f"üí∞ –ë–∞“ì–∞—Å—ã: {price}\n"
    )
    if pd.notna(book['URL']):
         message += f"üîó <a href=\"{book['URL']}\">–°–∞–π—Ç—Ç–∞–Ω “õ–∞—Ä–∞—É</a>\n"
    return message + "\n"

# --- (3) –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò TELEGRAM (–æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    categories = [cat for cat in books_df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'].unique() if cat != '–ë–µ–ª–≥—ñ—Å—ñ–∑']
    top_categories = categories[:9] 
    
    keyboard = []
    row = []
    for category in top_categories:
        row.append(InlineKeyboardButton(category, callback_data=f"cat_{category}"))
        if len(row) == 3:
            keyboard.append(row)
            row = []
    if row: keyboard.append(row)
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_html(
        f"–°”ô–ª–µ–º, {user.mention_html()}! üëã\n\n"
        f"–¢”©–º–µ–Ω–¥–µ–≥—ñ —Å–∞–Ω–∞—Ç—Ç—ã (–∫–∞—Ç–µ–≥–æ—Ä–∏—è–Ω—ã) —Ç–∞“£–¥–∞“£—ã–∑, –Ω–µ–º–µ—Å–µ –∫—ñ—Ç–∞–ø –∞—Ç–∞—É—ã–Ω –∂–∞–∑—ã“£—ã–∑:",
        reply_markup=reply_markup
    )

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    book_title_query = update.message.text
    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏—â–µ—Ç: '{book_title_query}'")
    try:
        recommendations = get_recommendations(book_title_query)
        if recommendations.empty:
            await update.message.reply_text("–ö–µ—à—ñ—Ä—ñ“£—ñ–∑, “±—Å—ã–Ω—ã—Å—Ç–∞—Ä —Ç–∞–±—ã–ª–º–∞–¥—ã. üòï")
            return
        response_message = f"<b>'{book_title_query}'</b> –∫—ñ—Ç–∞–±—ã–Ω–∞ “±“õ—Å–∞—Å “±—Å—ã–Ω—ã—Å—Ç–∞—Ä:\n\n"
        for _, book in recommendations.iterrows():
            response_message += format_book_message(book)
        await update.message.reply_html(response_message, disable_web_page_preview=True)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ: {e}")
        await update.message.reply_text("–û–π, –±—ñ—Ä “õ–∞—Ç–µ–ª—ñ–∫ –æ—Ä—ã–Ω –∞–ª–¥—ã.")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    callback_data = query.data
    
    if callback_data.startswith("cat_"):
        category_name = callback_data.split("_", 1)[1]
        logger.info(f"–ù–∞–∂–∞—Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è: {category_name}")
        category_books = books_df[books_df['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'] == category_name]
        
        if category_books.empty:
            await query.message.reply_text(f"<b>{category_name}</b> —Å–∞–Ω–∞—Ç—ã–Ω–¥–∞ –∫—ñ—Ç–∞–ø—Ç–∞—Ä —Ç–∞–±—ã–ª–º–∞–¥—ã.", parse_mode='HTML')
            return
            
        sample_books = category_books.sample(min(5, len(category_books)))
        response_message = f"<b>{category_name}</b> —Å–∞–Ω–∞—Ç—ã–Ω–¥–∞“ì—ã –∫–µ–∑–¥–µ–π—Å–æ“õ –∫—ñ—Ç–∞–ø—Ç–∞—Ä:\n\n"
        for _, book in sample_books.iterrows():
            response_message += format_book_message(book)
        await query.message.reply_html(response_message, disable_web_page_preview=True)

def main():
    if not TOKEN:
        logger.error("!!! –¢–û–ö–ï–ù –ù–ï –£–°–¢–ê–ù–û–í–õ–ï–ù !!!")
        logger.error("–ü—Ä–æ–≤–µ—Ä—å—Ç–µ .env —Ñ–∞–π–ª –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —Ö–æ—Å—Ç–∏–Ω–≥–∞.")
        return

    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    application.run_polling()

if __name__ == "__main__":
    main()